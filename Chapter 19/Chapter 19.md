# Chapter 19. 동적 프로그래밍

동적 프로그래밍에는 문제를 그 문제보다 더 작은 부분 문제들로 쪼개는 과정이 포함된다.  
동적 프로그래밍은 최적의 부분 문제들을 해결한 다음 이에 대한 결과를 메모리에 저장해 동일한 문제를 해결해야 하는 경우에 언제든지 이미 해결된 문제의 결과에 접근할 수 있도록 한다.  
이를 통해 알고리즘적인 복잡도는 크게 줄어든다.

### 동적 프로그래밍의 필요성

p. 371 ~ 373 참고

### 동적 프로그래밍의 규칙

동적 프로그래밍은 재계산을 피하기 위해 이미 계산된 값들을 저장하고 해당 값들을 사용하는 방법이다.  
이 방법은 중복 부분 문제들이 존재하고 최적 부분 구조가 존재하는 문제에만 적용할 수 있다.

##### 중복 부분 문제

재귀의 분할 정복과 마찬가지로 동적 프로그래밍은 부분 문제들의 해결책을 결합한다.  
동일한 부분 문제에 대한 해결책이 여러 번 사용되는 경우에 동적 프로그래밍을 사용한다.  
동적 프로그래밍은 보통 부분 문제의 해결책을 해시 테이블과 배열, 행렬에 저장하며, 이러한 방식을 메모이제이션이라 부른다.  
동적 프로그래밍은 문제 해결 시 중복 부분 문제가 많은 경우 유용하다.

결과를 저장해 재계산을 피하기 위해 해시 테이블을 사용할 수 있다.

##### 최적 부분 구조

어떤 문제의 최적 해결책을 해당 문제의 부분 문제들의 최적 해결책들을 사용해 찾을 수 있을 때 이를 최적 부분 구조라 한다.

##### 예: 걸음 수를 채우는 방법

n걸음 거리가 주어졌을 때 한 걸음, 두 걸음, 세 걸음을 가지고 n걸음을 채우는 여러 방법이 존재한다.  
예를 들어 n이 4인 경우, 4걸음을 채우기 위한 조합은 다음과 같이 총 4가지다.

1. 1걸음, 1걸음, 1걸음, 1걸음
2. 1걸음, 1걸음, 2걸음
3. 1걸음, 3걸음
4. 2걸음, 2걸음

```javascript
function waysToCoverSteps(step) {
  if(step < 0) return 0;
  if(step == 0) return 1;
  
  return waysToCoverSteps(step - 1) + waysToCoverSteps(step - 2) + waysToCoverSteps(step - 3);
}
waysToCoverSteps(12);
```

시간 복잡도: O(3^n)

위 재귀 메소드는 시간 복잡도가 높다.  
시간 복잡도를 최적화하기 위해 결과를 캐시에 저장해 값을 재계산하는 대신 저장된 결과를 사용한다.

```javascript
function waysToCoverStepsDP(step) {
  var cache = {};
  if(step < 0) return 0;
  if(step == 0) return 1;
  
  // 결과가 캐시에 존재하는지 확인한다.
  if(cache[step]) return cache[step];
  else cache[step] = waysToCoverStepsDP(step - 1) + waysToCoverStepsDP(step - 2) + waysToCoverStepsDP(step - 3);
  return cache[step];
}
waysToCoverStepsDP(12);
```

시간 복잡도: O(n)

### 대표적인 동적 프로그래밍 예

##### 배낭 문제 알고리즘

무게와 가치를 지니는 n개의 항목이 주어졌을 때 최대 w의 무게를 담을 수 있는 배낭에 해당 항목들을 집어넣어 배낭에 담긴 항목들의 가치의 합이 최대가 되도록 한다.

###### 최적 부분 구조

배열의 각 항목은 다음 두 가지 중 하나에 해당한다.

- 항목이 최적 부분집합에 포함된다.
- 항목이 최적 부분집합에 포함되지 않는다.

따라서 n개의 항목으로부터 얻을 수 있는 최대 가치는 다음 중 하나다.

1. (n번째 항목이 제외되는 경우): n - 1개의 항목에서 얻은 최대 가치
2. (n번째 항목을 포함하는 경우): n - 1개의 항목에서 얻은 최대 가치 + n번째 항목의 가치

###### 단순한 접근법

최적 부분 구조를 단순하게 구현하면 위에서 기술한 취적 부분 구조를 다음과 같이 재귀적으로 구현하면 된다.

시간 복잡도: O(2^n)

- knapsackNaive.js

###### 동적 프로그래밍 접근법

동적 프로그래밍 구현은 현재 배열 인덱스와 목표치를 자바스크립트 객체에 대한 키로 사용해 배낭 결과를 저장한다.

시간 복잡도: O(n * w)  
공간 복잡도: O(n * 2)

- knapsackDP.js

##### 최장 공통 부분 수열 알고리즘

p.379 ~ 382 참고

##### 동전 교환 알고리즘

p. 382 ~ 385 참고

##### 편집 거리 알고리즘

p. 386 ~ 389

### 요약

다음 조건을 만족할 때 알고리즘을 최적화하기 위해 동적 프로그래밍을 활용할 수 있다.

- 최적 부분 구조: 문제의 최적 해결책이 해당 문제의 부분 문제들의 최적 해결책을 포함한다.
- 중복 부분 문제: 부분 문제에 대한 해결책이 여러 번 필요하다.

부분 문제에 대한 이미 계산된 해결책을 저장하기 위해 행렬이나 해시 테이블을 주로 사용한다.  
행렬과 해시 테이블 모두 O(1) 찾기 시간을 제공하기 때문이다.  
이를 통해 시간 복잡도는 지수 시간에서 다항 시간으로 향상된다.