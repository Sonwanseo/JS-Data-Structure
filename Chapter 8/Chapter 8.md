# Chapter 8. 재귀

### 재귀 소개

수학과 언어학, 예술에서 재귀는 그 자신에 관해 정의한 것이 발생하는 것을 나타낸다.  
컴퓨터 과학 분야에서는 재귀함수는 자기 자신을 호출하는 함수다.  
재귀함수는 대개 우아하며 '분할 정복' 방식을 통해 복잡한 문제를 해결한다.

### 재귀의 규칙

재귀함수를 잘못 구현한 경우 재귀함수는 심각한 문제를 일으킨다.  
프로그램이 어느 한 곳에 빠져서 종료되지 않기 때문이다.  
무한 재귀호출은 스택 오버플로를 초래한다.  
스택 오버플로는 프로그램의 콜 스택 최대 개수가 제한된 양의 주소 공간을 초과할 때를 나타낸다.

재귀함수를 올바르게 구현하기 위해서는 스택 오버플로를 피하기 위한 특정 규칙을 따라야 한다.

##### 기저 조건

재귀에는 기저 조건이 존재한다.  
재귀 메소드는 자기 자신을 호출하기 때문에 기저 조건에 도달하지 않으면 중단되지 않고 계속 자기 자신을 호출한다.  
재귀로 인한 스택 오버플로는 올바른 기저 조건을 갖추지 못한 결과일 가능성이 매우 높다.  
기저 조건에서는 더 이상 재귀함수 호출을 하지 않는다.

```javascript
function countDownToZero(n) {
  // 기저 조건. 0에서 중단한다.
  if(n < 0) {
    return; // 함수를 중단한다.
  } else {
    console.log(n);
    countDownToZero(n - 1); // 1만큼 감소시킨다.
  }
}
countDownToZero(12);
```

##### 분할 정복 방식

컴퓨터 과학 분야에서 분할 정복 방식은 어떤 문제를 작은 단위로 나눠서 해당 작은 단위의 문제들을 모두 해결함으로써 문제를 해결하는 것을 말한다.  
문제는 '분할 정복'에 의해 점점 작아지면서 기저 경우에 도달해야 한다.  
그렇지 않으면 재귀 호출은 기저 사례에 수렴하지 못해 스택 오버플로가 발생할 것이다.

##### 대표적인 예: 피보나치 수열

피보나치 수열은 무한한 숫자들의 목록이다.  
이 때 각 수는 이전 두 수의 합이다.

##### 반복 루프를 활용한 해결책: 피보나치 수열

```javascript
function getNthFibo(n) {
  if (n <= 1) return n;
  var sum = 0, last = 1, lastlast = 0;
  
  for(let i = 1; i < n; i++) {
    sum = lastlast + last;
    lastlast = last;
    last = sum;
  }
  
  return sum;
}
```

for 루프는 피보나치 수열의 마지막 두 개 항목을 추적하는 데 사용될 수 있다.  
마지막 두 개 항목의 합이 피보나치 수가 된다.

##### 재귀 해결법: 피보나치

```javascript
function getNthFibo(n) {
  if(n <= 1) return n;
  else return getNthFibo(n - 1) + getNthFibo(n - 2);
}
```

##### 피보나치 수열: 꼬리 재귀

꼬리 재귀 함수는 재귀 호출이 함수에서 가장 마지막에 실행되는 방식의 재귀함수다.

```javascript
function getNthFibo(n) {
  if(n <= 1) return n;
  var sum = 0, last = 1, lastlast = 0;
  
  for(let i = 1; i < n; i++) {
    sum = lastlast + last;
    lastlast = last;
    last = sum;
  }
  return sum;
}
```

매번 루프가 반복될 때마다 다음 갱신이 일어난다.

```
(lastlast, last) = (last, lastlast + last)
```

이러한 점을 염두해 다음과 같이 재귀함수를 구현할 수 있다.

```javascript
function getNthFiboBetter(n, lastlast, last) {
  if(n == 0) return lastlast;
  if(n == 1) return last;
  return getNthFiboBetter(n - 1, last, lastlast + last);
}
```

시간 복잡도: O(n)  
공간 복잡도: O(n)

##### 파스칼의 삼각형

파스칼의 삼각형은 어떤 항목의 값이 해당 항목의 위쪽 두 개 항목 값의 합인 삼각형이다.

기저 경우: 파스칼의 삼각형의 기저 경우는 최상위 항목인 1이다.  
나머지 모든 수는 해당 항목으로부터 파생된 것이다.  
따라서 열이 1이면 1을 반환하고 행이 0이면 0을 반환한다.

분할 정복: 파스칼의 삼각형의 수학적 정의에 따르면 파스칼의 삼각형의 수는 해당 수의 위쪽 수들의 합이다.

```javascript
function pascalTriangle(row, col) {
  if(col == 0) return 1;
  else if(row == 0) return 0;
  else return pascalTriangle(row - 1, col) + pascalTriangle(row - 1, col - 1);
}
pascalTriangle(5, 2); 10;
```

### 재귀의 빅오 분석

재귀 알고리즘에 대한 빅오 분석을 수해앟기 위해서는 알고리즘이 어떤 식으로 반복되는지 점화식을 분석해야 한다.

##### 점화식

반복 루프를 사용해 구현된 알고리즘의 경우 빅오 분석이 훨씬 간단하다.  
루프가 언제 중단돼야 할지 그리고 각 반복 루프마다 얼마나 증가시켜야 할지를 명확하게 정의하기 때문이다.  
재귀 알고리즘을 분석하는 경우 점화식을 사용한다.  
점화식은 기저 경우에 대한 빅오와 재귀 경우데 해나 빅오 두 부분에 대한 분석으로 구성된다.

``` javascript
function getNthFibo(n) {
  if(n <= 1) return n;
  else return getNthFibo(n - 1) + getNthFibo(n - 2);
}
getNthFibo(3);
```

기저 경우의 시간 복잡도는 O(1)이다.  
재귀 경우는 자기 자신을 두 번 호출한다.  
이를 T(n) = T(n - 1) + T(n - 2) + O(1)이라고 표현하자.

- 기저 경우: T(n) = O(1)
- 재귀 경우: T(n) = T(n - 1) + T(n - 2) + O(1)

함수를 호출할 때마다 각 함수 호출에 대해 두 개의 함수 호출이 더 일어난다.  
즉, 이 함수의 시간 복잡도는 O(2^n)이다.

빅오를 계산하는 것은 어렵고 실수하기 쉽다.  
다행히도 이를 계산하는 데 도움이 되는 마스터 정리라는 개념이 있다.  
마스터 정리 덕분에 프로그래머들은 재귀 알고리즘의 시간 복잡도와 공간 복잡도를 쉽게 분석할 수 있다.

##### 마스터 정리

마스터 정리는 다음과 같이 기술한다.

> a >= 1이고 b >= 1인 T(n) = aT(n/b) + O(n^c)의 형태를 지닌 점화석이 있을 때 세 가지 경우가 존재한다.

a는 재귀 호출에 곱해지는 계수다.  
b는 로그 항이다.  
b는 재귀 호출 시에 n을 나누는 항이다.  
마지막으로 c는 등식의 비재귀 구성 요소에 대한 다항식의 항이다.

세 가지 경우에 관한 내용은 p.149 ~p.150을 참고하자.

### 재귀 호출 스택 메모리

재귀함수가 자기 자신을 호출하는 경우 메모리를 차지한다.  
따라서 이는 빅오 공간 복잡도 분석에서 매우 중요하다.

예를 들어 n부터 1까지 재귀적으로 출력하는 간단한 함수의 공간 복잡도는 O(n)이다.

각 재귀 호출은 기저 경우가 해결될 때까지 메모리에 저장돼야 한다.  
이러한 콜 스택으로 인해 재귀 알고리즘은 추가적인 메모리를 필요로 한다.

재귀 호출은 운영체제의 메모리 스택에 저장돼야 하는데, 재귀함수는 이러한 재귀 호출로 인해 발생하는 추가적인 공간 복잡도 비용을 지닌다.  
스택은 기저 경우가 해결될 때까지 축적된다.  
최악의 상황으로 기저 경우가 잘못 구현된 경우 재귀함수는 스택 오버플로 오류로 인해 프로그램에 치명적 오류를 일으키며 프로그램을 중단시킬 것이다.  
스택 오버플로 오류는 메모리 스택에 허용된 수의 항목보다 많은 수가 있는 경우에 발생한다.

### 요약

재귀는 복잡한 알고리즘을 구현하기 위한 강력한 도구다.  
모든 재귀함수는 두 가지 부분으로 구성됨을 기억하자.  
바로 기저 경우와 분할 정복 방식이다.

이러한 재귀 알고리즘의 빅오 분석은 경험적으로 수행되거나 마스터 정리를 통해 수행된다.  
마스터 정리는 점화식을 필요로 한다는 점을 기억하자.  
마스터 정리를 사용하는 경우 해당 경우가 마스터 정리의 세 가지 중 어디에 속하는지 결정하기 위해 a와 b, c를 식별해야 한다.

마지막으로 재귀 알고리즘을 구현할 때 재귀함수 호출의 콜 스택으로 인한 추가적인 메모리를 고려해야 한다.  
각 재귀 호출은 실행 시간에 콜 스택에서의 공간을 필요로 한다.  
콜 스택이 n 호출만큼 축적된 경우 해당 함수의 공간 복잡도는 O(n)이다.