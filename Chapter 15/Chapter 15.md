# Chapter 15. 트리

일반적인 트리 자료 구조는 자식 노드를 지닌 노드들로 구성된다.  
첫 번째 가장 상위 노드를 루트 노드라고 부른다.

### 일반적인 트리 구조

일반적인 트리 구조는 자식을 얼마든지 가질 수 있다.

- Tree.js

### 이진 트리

이진 트리는 자식 노드가 왼쪽, 오른쪽 두 개뿐인 트리다.

이진 트리에는 항상 루트 노드(최상위에 있는 노드)가 있다.  
루트 노드는 다른 삽입된 항목이 없을 때 null로 초기화돼 있다.

- BinaryTree.js

### 트리 순회

트리의 모든 항목을 방문하기 위해 왼쪽 포인터와 오른쪽 포인터가 존재한다.

순회를 위한 다양한 방법이 존재하는데, 가장 널리 사용되는 순회 기법으로 선순위 순회, 후순위순 순회, 중순위 순회, 단계순위 순회가 있다.

##### 선순위 순회

선순위 순회는 루트, 왼쪽, 오른쪽 순으로 노드를 방문한다.

이는 재귀적으로 쉽게 구현할 수 있다.  
기저 조건은 노드가 null일 때 종료된다.  
노드가 null이 아니면 값을 출력한다.  
그런 다음 왼쪽 자식에 대해 재귀함수를 호출하고 오른쪽 자식에 대해 재귀함수를 호출한다.

- BinaryTree.js

##### 중순위 순회

중순위 순회는 왼쪽, 루트, 오른쪽 순으로 노드를 방문한다.

중순위 순회도 재귀를 사용하면 쉽게 구현할 수 있다.  
기저 경우는 노드가 null일 때다.  
기저 경우가 아닌 경우에는 왼쪽 자식에 대해 재귀함수를 호출한 다음 현재 노드를 출력하고 그 다음 오른쪽 자식에 대해 재귀함수를 호출한다.

- BinaryTree.js

##### 후순위 순회

후순위 순회는 왼쪽, 오른쪽, 루트 순으로 노드를 방문한다.

- BinaryTree.js

##### 단계순위 순회

단계순위 순회는 너비 우선 탐색(BFS, breadth first search)이라고도 부른다.

단계순위 순회 방법의 핵심은 왼쪽 혹은 오른쪽으로 깊게 들어가는 대신에 각 노드 단계를 방문한다는 점이다.

- BinaryTree.js

##### 트리 순회 요약

|                            상황                             |  순회 방법  |                             이유                             |
| :---------------------------------------------------------: | :---------: | :----------------------------------------------------------: |
|   잎 노드를 방문하기 전에 루트를 조사할 필요가 있는 경우    | 선순위 순회 |     잎 노드를 방문하기 전에 모든 루트를 방문하기 때문에      |
| 부모 노드를 방문하기 전에 잎 노드를 먼저 조사해야 하는 경우 | 후순위 순회 | 잎 노드를 검색할 때 루트를 조사하느라 시간을 낭비하지 않기 때문에 |
|           트리를 원래 순서대로 방문하고 싶은 경우           | 중순위 순회 |                              X                               |

시간 복잡도: O(n)

위의 순회는 모두 모든 노드를 방문해야 하기 때문에 시간 복잡도가 동일하다.

### 이진 검색 트리

이진 검색 트리 역시 왼쪽과 오른쪽 두 개의 자식이 있다.  
하지만 왼쪽 자식이 부모보다 작고 오른쪽 자식이 부모보다 크다.  
이진 검색 트리가 이런 구조를 지닌 이유는 검색과 삽입, 특정 값을 지닌 노드 제거의 시간 복잡도가 O(log2(n))이기 때문이다.

이진 검색 트리는 루트 노드가 있다.  
루트 노드는 최초에 null로 초기화된다.

자식이 왼쪽과 오른쪽 모두에 있어 높이가 최소화된 균형 이진 검색 트리가 있는 반면,  
자식이 부모의 오른쪽에만 있는 불균형 이진 검색 트리도 존재할 수 있다.  
이는 자료 구조에 큰 영향을 끼치며 삽입과 삭제, 검색의 시간 복잡도를 O(log2(n))에서 O(n)으로 증가시킨다.  
완전 균형 트리의 높이는 log2(n)인 반면 불균형 트리의 높이는 최악의 경우 n이 된다.

- BinarySearchTree.js

##### 삽입

이진 검색 트리에 노드를 삽입하는 것은 두 단계로 구성된다.  
첫째 루트가 빈 경우 루트가 신규 노드가 된다.  
루트가 비어 있지 않다면 while 루프를 사용해 조건이 만족될 때까지 이진 검색 트리를 순회한다.  
각 루프 반복 시 신규 노드가 현재 루트보다 크거나 작은지 확인한다.

시간 복잡도(균형 트리): O(log2(n))  
시간 복잡도(불균형 트리): O(n)

- BinarySearchTree.js

##### 삭제

삭제 알고리즘은 우선 삭제하고자 하는 값을 지닌 노드를 찾기 위해 트리를 순회한다.  
해당 노드를 찾은 경우 다음 세 가지 경우가 있다.

- 노드에 자식이 없는 경우: null 반환
- 노드에 자식이 하나 있는 경우: 해당 자식이 위 단계로 올라가서 부모를 대체한다.
- 노드에 자식이 둘 있는 경우: 왼쪽 하위 트리의 최대치를 찾거나 오른쪽 하위 트리의 최소치를 찾아서 해당 노드를 대체한다.

시간 복잡도(균형 트리): O(log2(n))  
시간 복잡도(불균형 트리): O(n)

- BinarySearchTree.js

##### 검색

이진 검색 트리의 경우 노드의 왼쪽 자식이 부모보다 항상 작고 오른쪽 자식이 부모보다 항상 크다는 특성을 사용해 검색을 수행할 수 있다.  
현재 루트가 검색 값보다 작거나 큰지 확인함으로써 트리를 순회할 수 있다.

시간 복잡도(균형 트리): O(log2(n))  
시간 복잡도(불균형 트리): O(n)

- BinarySearchTree.js

### AVL 트리

AVL은 스스로 균형을 잡는 이진 검색 트리다.  
AVL은 이진 검색 트리의 높이를 최소로 유지하며 검색과 삽입, 삭제 연산의 시간 복잡도 O(log2(n))을 보장한다.

AVL 트리의 높이는 자식의 높이를 기반으로 한다.

- AVLTree.js

##### 단일 회전

AVL 트리는 삽입 이후에 균형을 유지하기 위해 자식들을 회전한다.

###### 왼쪽 회전

p. 274 ~ 275 참고

- AVLTree.js

###### 오른쪽 회전

p. 276 ~ 277 참고

- AVLTree.js

##### 이중 회전

한 번의 회전을 한 이후에도 AVL 트리가 여전히 불균형이라면 완전한 균형을 위해 두 번 회전해야 한다.

###### 오른쪽 왼쪽 회전(오른쪽 이후에 왼쪽)

p. 277 ~ 278 참고

###### 왼쪽 오른쪽 회전(왼쪽 이후에 오른쪽)

p. 278 ~ 279 참고

##### 트리 균형 잡기

AVL 트리의 균형을 확인하기 위해서는 왼쪽 자식과 오른쪽 자식의 높이를 간단히 비교하면 된다.  
높이가 균형이 맞지 않는 경우 회전이 필요하다.

- AVLTree.js

##### 삽입

AVL 이진 검색 트리의 삽입 이후에 부모가 자식의 균형을 잡은 다음 깊이 값을 설정해야 한다는 점을 제외하고는 일반적인 이진 검색 트리와 동일하다.

시간 복잡도: O(nlog2(n))  
공간 복잡도: O(nlog2(n))

- AVLTree.js

##### 삭제

AVL 이진 검색 트리는 이진 검색 트리의 일종이므로 삭제 함수가 동일하다.  
순회하는 동안 setDepthBasedOnChildren()을 호출해 길이를 조정한다.

AVL 트리가 균형 잡혀 있기 때문에 시간 복잡도와 공간 복잡도 모두 O(nlog2(n))이다.  
공간 복잡도는 메모리의 재귀 호출 스택 때문이다.

- AVLTree.js

##### AVL 트리 예제 종합

- AVLTree.js

### 요약

다른 자료 구조와 비교할 때 검색 연산은 연결 리스트와 배열, 스택, 큐보다 빠르다.  
이진 검색 트리는 무언가를 검색하는 데 뛰어나다.  
하지만 삽입과 삭제 연산의 시간 복잡도는 O(log2(n))으로 느리다.  
게다가 트리가 불균형이 되면 모든 연산은 O(n)이 된다.  
트리의 균형을 유지해 트리 연산이 로그 시간 복잡도를 지니도록 하기 위해서는 적흑 트리나 AVL 트리와 같은 자가 균형 트리를 사용해야 한다.

| 연산 | 최적(균형) | 최악(완전 불균형) |
| ---- | ---------- | ----------------- |
| 삭제 | O(log2(n)) | O(n)              |
| 삽입 | O(log2(n)) | O(n)              |
| 검색 | O(log2(n)) | O(n)              |