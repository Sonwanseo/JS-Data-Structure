# Chapter 18. 고급 문자열

### 트라이(접두사 트리)

트라이는 문자열을 검색해 저장된 문자열 중 일치하는 문자열이 있는지 확인하는 데 주로 사용되는 특별한 종류의 트리다.  
각 단계에서 노드는 단어를 완성하기 위해 가지를 친다.

각 마지막 노드에는 endOfWord라는 불리언 플래그가 있다.  
이는 어떤 단어가 해당 경로에서 종료되는지 여부를 나타낸다.

p. 352 그림 18-1 참고

트라이는 중첩 객체를 사용해 구현한다.  
이때 각 노드는 자신과 직접 연결된 자식들을 지니는데 이 자식들은 키 역할을 한다.

트라이에 신규 노드를 삽입할 때 해당 노드가 루트의 자식으로 존재하지 않는 경우 해당 노드를 루트의 자식으로 생성해야 한다.

트라이에서 어떤 단어가 존재하는지 검색하기 위해서는 단어의 각 문자를 확인해야 한다.  
이를 위해서는 임시 변수 current를 루트에 설정해야 한다.  
검색하고자 하는 단어의 각 문자를 확인함에 따라 current 변수가 갱신된다.

트라이로부터 항목을 삭제하기 위해서는 검색 알고리즘이 루트 노드로부터 삭제하고자 하는 단어의 마지막 문자에 도달할 때까지 트라이를 순회해야 한다.  
그러고 나서 삭제하고자 하는 단어의 문자에 해당하는 자식 외의 다른 자식을 지니지 않은 각 노드를 삭제해야 한다.

모든 연산(삽입, 검색, 삭제)에 대해 시간 복잡도는 O(W)이다.  
여기서 W는 검색하고자 하는 문자열의 길이다.

공간 복잡도는 O(N * M)이다.  
여기서 N은 트라이에 삽입된 단어의 개수이고 M은 가장 긴 단어의 길이다.  
따라서 공통 접두어를 지닌 다수의 문자열이 있는 경우에 트라이는 효율적인 자료 구조다.  
하나의 특정 문자열에서 하나의 특정 문자열 패턴을 검색하는 경우 트라이는 효율적이지 않다.  
트리와 같은 구조에 문자열을 저장하기 위해 추가적인 메모리가 필요하기 때문이다.

하나의 문자열을 대상으로 패턴 검색을 하는 경우 보이어-무어 알고리즘과 커누스-모리스-프랫 알고리즘으 유용하다.

- Trie.js

### 보이어-무어 문자열 검색

보이어-무어 문자열 검색 알고리즘은 텍스트 편집기 애플리케이션과 웹브라우저의 '찾기' 기능에 사용된다.

보이어-무어 문자열 검색 알고리즘을 사용하면 문자열 내에서 패턴을 검색할 때 인덱스를 건너뜀으로써 선형 시간에 검색이 가능하다.

건너뛰기 규칙을 구현하기 위해 '불일치 표' 구조를 만들 수 있다.  
불일치 표는 어떤 패턴의 주어진 문자에 대해 얼마나 건너뛰어야 할지를 나타낸다.

패턴으로 사용할 문자열을 입력받을 때 검색하고자 하는 현재 문자열이 불일치 표에 존재하는 경우, 현재 문자열과 연관된 불일치 표 값만큼 인덱스를 건너뛴다.  
반면 현재 문자열이 불일치 표에 존재하지 않는 경우 인덱스를 1만큼 증가시킨다.  
이러한 과정은 계속 반복되다가 문자열이 발견되거나 인덱스가 패턴 길이와 문자열 길이의 차보다 큰 경우에 중단된다.

최선의 경우 패턴의 모든 문자가 동일해 T만큼 일관되게 이동한다.  
여기서 T는 패턴의 길이이다.  
따라서 O(W/T)가 최선의 경우의 시간 복잡도이다.  
여기서 W는 패턴을 찾고자 하는 대상인 문자열이다.

시간 복잡도: O(W/T)  
공간 복잡도: O(1)

최악의 경우 패턴이 문자열의 끝에 존재하고 앞부분이 모두 고유의 문자로 구성된 경우다.

시간 복잡도: O(T * W)
공간 복잡도: O(T)

패턴과 문자열의 모든 문자가 동일한 경우도 있다.  
이 경우 인덱스가 항상 1만큼 증가하기 때문에 건너뛰기 방식을 최대한 활용할 수 없다.  
패턴의 문자가 모두 유일할 수 있기 때문에 공간 복잡도는 T이다.

- boyerMoore.js

### 커누스-모리스-플랫 문자열 검색

String 객체의 내장 메서드인 indexOf 보다 더 나은(빠른) 구현을 위해서는 커누스-모리스-플랫 문자열 검색 알고리즘을 사용할 수 있다.  
KMP 알고리즘의 다음 구현은 패턴이 존재하는 곳의 모든 인덱스를 반환한다.

KMP 문자열 검색 알고리즘은 입력 "텍스트" T 내에서 "단어" W의 출현 횟수를 검색한다.  
이때 잘못된 일치가 발생하면 이로부터 다음 일치가 어디에서 시작될 수 있는지에 관한 충분한 정보를 얻을 수 있다는 점을 활용한다.  
이는 이미 일치한 문자들을 다시 검사하는 것을 막아준다.  
접두사 배열을 만들 때 접두사 배열이 동일한 접두사를 얻기 위해 인덱스를 얼마나 되돌려야 할지를 나타낼 수 있도록 해야 한다.

p. 360 ~ 363 참고

KMP 검색은 문자열과 검색하고자 하는 패턴을 인덱스마다 반복한다.  
불일치가 있을 때마다 접두사 표를 사용해 다음에 시도할 새로운 인덱스를 계산한다.

패턴의 인덱스가 패턴의 길이에 도달했다는 것은 문자열을 발견했다는 의미다.

- KMP.js

### 라빈-카프 검색

라빈-카프 알고리즘은 텍스트에서 특정 패턴을 찾기 위해 해싱을 활용한다.  
KMP가 검색하는 동안 중복되는 확인을 건너뛰도록 최적화된 반면, 라빈-카프는 해시 함수를 통해 부분 문자열이 패턴과 동일한지 비교하는 과정의 속도를 높인다.  
이를 효율적으로 수행하기 위해 해시 함수는 O(1)이어야 한다.  
라빈-카프 검색에 사용된 해싱은 라빈 지문 해싱 기법이 사용됐다.

##### 라빈 지문

p. 365 참고

선처리 시간 복잡도: O(W)  
W는 "단어"의 길이이다.

일치 시간 복잡도: O(W+ T)  
최대로 잡았을 때 위 알고리즘은 길이 T와 길이 W의 합만큼 반복한다.  
여기서 T는 검색하고자 하는 문자열의 길이이다.

- RabinKarpSearch.js

##### 실생활 적용 예

라빈-카프 알고리즘은 표절을 잡아내는 데 사용될 수 있다.  
원본 자료가 있는 경우 라빈-카프 알고리즘은 제출한 문서를 검색해 원문에 있는 구문과 단어가 제출한 문서에 얼마나 등장하는지 알아낼 수 있다.

단일 검색 알고리즘의 경우 이러한 문제를 해결하는 데 적합하지 않다.  
찾고자 하는 구문과 문장이 너무 많이 때문이다.  
라빈-카프 알고리즘은 대규모 DNA 자료에서 특정 시퀀스를 찾는 것과 같이 문자열 일치 비교 애플리케이션에서도 사용된다.

### 요약

- 트라이는 다중 검색과 접두사 패턴 일치 확인에 뛰어나다.
- 보이어-무어는 끝부분이 일치하지 않으면 처음 부분을 비교해보지 않아도 된다는 가정 아래 패턴의 처음이 아닌 마지막 문자를 비교햔다.  
  덕분에 인덱스를 뛰어넘을 수 있어서 텍스트 양이 많은 경우 효율적이다.
- KMP 알고리즘은 문자열 내에 패턴의 등장 횟수를 검색한다.
  이는 불일치가 일어났을 때 패턴 자체가 다음 비교를 어디에서 해야 할지 결정하는 데 충분한 정보를 지닌다는 관찰을 바탕으로 한다.
  따라서 KMP 알고리즘은 텍스트의 양이 작은 경우에 효율적이다.

| 알고리즘    | 전처리 시간 복잡도 | 일치 비교 시간 복잡도                            | 공간 복잡도 |
| ----------- | ------------------ | ------------------------------------------------ | ----------- |
| 기본        | 없음               | O(W * T)                                         | 없음        |
| 보이어-무어 | O(W + T)           | 최선의 경우: O(T / W)<br />최악의 경우: O(W * T) | O(1)        |
| KMP         | O(W)               | O(T)                                             | O(W)        |
| 라빈-카프   | O(W)               | O(W + T)                                         | O(1)        |

